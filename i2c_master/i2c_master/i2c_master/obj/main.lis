 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area data(ram, con, rel)
 0000                   .dbfile ./main.c
 0000           _buf_tx::
 0000 414200            .byte 'A,'B,0
 0003 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000  .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 003F 00                .byte 0
 0040                   .dbfile C:\src\psoc\CY8C29~1\designer\i2c-uart\I2C_MA~1\I2C_MA~1\I2C_MA~1\main.c
 0040                   .dbsym e buf_tx _buf_tx A[64:64]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\src\psoc\CY8C29~1\designer\i2c-uart\I2C_MA~1\I2C_MA~1\I2C_MA~1\main.c
                        .area text(rom, con, rel)
 0000                   .dbfile C:\src\psoc\CY8C29~1\designer\i2c-uart\I2C_MA~1\I2C_MA~1\I2C_MA~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 27
 0000           ; // I2C-UART master
 0000           ; // CY8C29466-24PXI(DIP Package)
 0000           ; // PSoC Designer 5.0 + SP6
 0000           ; // IMAGECRAFT C Compiler
 0000           ; 
 0000           ; #include <m8c.h>        // part specific constants and macros
 0000           ; #include <I2CHW_1Common.h>
 0000           ; #include <I2CHW_1Mstr.h>
 0000           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0000           ; #define _BV(BIT) (1<<BIT)
 0000           ; #define sbi(BYTE,BIT) (BYTE |= _BV(BIT))
 0000           ; #define cbi(BYTE,BIT) (BYTE &= ~_BV(BIT))
 0000           ; #define LED_ON() sbi(PRT2DR, 0)
 0000           ; #define LED_OFF() cbi(PRT2DR, 0)
 0000           ; #define bit_is_set(BYTE, BIT) BYTE & BIT
 0000           ; #define loop_until_bit_is_set(BYTE, BIT) while(!bit_is_set(BYTE,BIT));
 0000           ; #define SW_PORT PRT2DR
 0000           ; #define SW_BIT _BV(2) // switch
 0000           ; 
 0000           ; #define BUF_SIZE 64
 0000           ; BYTE buf_tx[BUF_SIZE] = "AB";
 0000           ; BYTE buf_rx[BUF_SIZE];
 0000           ; #define SLAVE_ADDR 0
 0000           ; BYTE status;
 0000           ; 
 0000           ; void main(void)
 0000           ; {
 0000                   .dbline 28
 0000           ;     M8C_EnableGInt; // enable global interrupt
 0000 7101                      or  F, 01h
 0002           
 0002                   .dbline 29
 0002           ;     M8C_EnableIntMask(INT_MSK0, INT_MSK0_GPIO);
 0002 43E020            or REG[0xe0],32
 0005                   .dbline 30
 0005           ;     UART_1_CmdReset(); // uart init
 0005 10                push X
 0006 7C0000            xcall _UART_1_CmdReset
 0009 20                pop X
 000A                   .dbline 31
 000A           ;     UART_1_IntCntl(UART_1_ENABLE_RX_INT); // enable receive interrupt
 000A 10                push X
 000B 5001              mov A,1
 000D 7C0000            xcall _UART_1_IntCntl
 0010 20                pop X
 0011                   .dbline 32
 0011           ;     UART_1_Start(UART_1_PARITY_NONE);
 0011 10                push X
 0012 5000              mov A,0
 0014 7C0000            xcall _UART_1_Start
 0017 20                pop X
 0018                   .dbline 33
 0018           ;     LED_ON();
 0018 430801            or REG[0x8],1
 001B                   .dbline 34
 001B           ;     UART_1_CPutString("start");
 001B 10                push X
 001C 5017              mov A,>L2
 001E 08                push A
 001F 5017              mov A,<L2
 0021 5C                mov X,A
 0022 18                pop A
 0023 7C0000            xcall _UART_1_CPutString
 0026                   .dbline 35
 0026           ;     I2CHW_1_Start();
 0026 7C0000            xcall _I2CHW_1_Start
 0029                   .dbline 36
 0029           ;     I2CHW_1_EnableMstr();
 0029 7C0000            xcall _I2CHW_1_EnableMstr
 002C                   .dbline 37
 002C           ;     I2CHW_1_EnableInt();
 002C 7C0000            xcall _I2CHW_1_EnableInt
 002F 20                pop X
 0030                   .dbline 39
 0030           ; 
 0030           ;     for(;;){
 0030           L3:
 0030                   .dbline 39
 0030                   .dbline 40
 0030           ;         I2CHW_1_bWriteBytes(SLAVE_ADDR, buf_tx, BUF_SIZE, I2CHW_1_CompleteXfer);
 0030 10                push X
 0031 5000              mov A,0
 0033 08                push A
 0034 5040              mov A,64
 0036 08                push A
 0037 5000              mov A,>_buf_tx
 0039 08                push A
 003A 5000              mov A,<_buf_tx
 003C 08                push A
 003D 5000              mov A,0
 003F 08                push A
 0040 7C0000            xcall _I2CHW_1_bWriteBytes
 0043 38FB              add SP,-5
 0045 20                pop X
 0046           L7:
 0046                   .dbline 41
 0046           ;         while(!(I2CHW_1_bReadI2CStatus() & I2CHW_WR_COMPLETE));
 0046           L8:
 0046                   .dbline 41
 0046 10                push X
 0047 7C0000            xcall _I2CHW_1_bReadI2CStatus
 004A 62D000            mov REG[0xd0],>__r0
 004D 20                pop X
 004E 5300              mov [__r0],A
 0050 470040            tst [__r0],64
 0053 AFF2              jz L7
 0055                   .dbline 42
 0055           ;         I2CHW_1_ClrWrStatus();
 0055 10                push X
 0056 7C0000            xcall _I2CHW_1_ClrWrStatus
 0059 20                pop X
 005A                   .dbline 44
 005A           ; 
 005A           ;         I2CHW_1_fReadBytes(SLAVE_ADDR, buf_rx, BUF_SIZE, I2CHW_1_CompleteXfer);
 005A 10                push X
 005B 5000              mov A,0
 005D 08                push A
 005E 5040              mov A,64
 0060 08                push A
 0061 5000              mov A,>_buf_rx
 0063 08                push A
 0064 5000              mov A,<_buf_rx
 0066 08                push A
 0067 5000              mov A,0
 0069 08                push A
 006A 7C0000            xcall _I2CHW_1_fReadBytes
 006D 38FB              add SP,-5
 006F 20                pop X
 0070           L10:
 0070                   .dbline 45
 0070           ;         while(!(I2CHW_1_bReadI2CStatus() & I2CHW_RD_COMPLETE));
 0070           L11:
 0070                   .dbline 45
 0070 10                push X
 0071 7C0000            xcall _I2CHW_1_bReadI2CStatus
 0074 62D000            mov REG[0xd0],>__r0
 0077 20                pop X
 0078 5300              mov [__r0],A
 007A 470004            tst [__r0],4
 007D AFF2              jz L10
 007F                   .dbline 46
 007F           ;         I2CHW_1_ClrRdStatus();
 007F 10                push X
 0080 7C0000            xcall _I2CHW_1_ClrRdStatus
 0083 20                pop X
 0084           L13:
 0084                   .dbline 48
 0084           ; 
 0084           ;         while(!(UART_1_bReadTxStatus() & UART_1_TX_BUFFER_EMPTY));
 0084           L14:
 0084                   .dbline 48
 0084 10                push X
 0085 7C0000            xcall _UART_1_bReadTxStatus
 0088 62D000            mov REG[0xd0],>__r0
 008B 20                pop X
 008C 5300              mov [__r0],A
 008E 470010            tst [__r0],16
 0091 AFF2              jz L13
 0093                   .dbline 49
 0093           ;         UART_1_PutString(buf_rx);
 0093 10                push X
 0094 5000              mov A,>_buf_rx
 0096 08                push A
 0097 5000              mov A,<_buf_rx
 0099 5C                mov X,A
 009A 18                pop A
 009B 7C0000            xcall _UART_1_PutString
 009E 20                pop X
 009F                   .dbline 50
 009F           ;     }
 009F                   .dbline 39
 009F                   .dbline 39
 009F 8F90              xjmp L3
 00A1           X0:
 00A1                   .dbline -2
 00A1           L1:
 00A1                   .dbline 0 ; func end
 00A1 8FFF              jmp .
 00A3                   .dbend
 00A3                   .dbfunc e INT_UART_RX _INT_UART_RX fV
 00A3           ;      recv_data -> X+0
 00A3           _INT_UART_RX::
 00A3                   .dbline -1
 00A3 71C0              or F,-64
 00A5 08                push A
 00A6 5DD0              mov A,REG[0xd0]
 00A8 08                push A
 00A9 5DD3              mov A,REG[0xd3]
 00AB 08                push A
 00AC 5DD4              mov A,REG[0xd4]
 00AE 08                push A
 00AF 5DD5              mov A,REG[0xd5]
 00B1 08                push A
 00B2 62D000            mov REG[0xd0],>__r0
 00B5 5100              mov A,[__r0]
 00B7 08                push A
 00B8 5100              mov A,[__r1]
 00BA 08                push A
 00BB 5100              mov A,[__r2]
 00BD 08                push A
 00BE 5100              mov A,[__r3]
 00C0 08                push A
 00C1 5100              mov A,[__r4]
 00C3 08                push A
 00C4 5100              mov A,[__r5]
 00C6 08                push A
 00C7 5100              mov A,[__r6]
 00C9 08                push A
 00CA 5100              mov A,[__r7]
 00CC 08                push A
 00CD 5100              mov A,[__r8]
 00CF 08                push A
 00D0 5100              mov A,[__r9]
 00D2 08                push A
 00D3 5100              mov A,[__r10]
 00D5 08                push A
 00D6 5100              mov A,[__r11]
 00D8 08                push A
 00D9 5100              mov A,[__rX]
 00DB 08                push A
 00DC 5100              mov A,[__rY]
 00DE 08                push A
 00DF 5100              mov A,[__rZ]
 00E1 08                push A
 00E2 10                push X
 00E3 4F                mov X,SP
 00E4 3803              add SP,3
 00E6                   .dbline 55
 00E6           ; }
 00E6           ; 
 00E6           ; 
 00E6           ; #pragma interrupt_handler INT_UART_RX
 00E6           ; void INT_UART_RX(void){
 00E6                   .dbline 57
 00E6           ;     char recv_data;
 00E6           ;     recv_data = UART_1_cGetChar(); // read UART
 00E6 10                push X
 00E7 7C0000            xcall _UART_1_cGetChar
 00EA 62D000            mov REG[0xd0],>__r0
 00ED 20                pop X
 00EE 5400              mov [X+0],A
 00F0                   .dbline 58
 00F0           ;     UART_1_PutChar(recv_data); // echo
 00F0 10                push X
 00F1 5200              mov A,[X+0]
 00F3 7C0000            xcall _UART_1_PutChar
 00F6 20                pop X
 00F7                   .dbline 59
 00F7           ;     switch(recv_data){
 00F7 5200              mov A,[X+0]
 00F9 5402              mov [X+2],A
 00FB 560100            mov [X+1],0
 00FE 5202              mov A,[X+2]
 0100 1144              sub A,68
 0102 62D000            mov REG[0xd0],>__r0
 0105 5300              mov [__rY],A
 0107 5201              mov A,[X+1]
 0109 3180              xor A,-128
 010B 1980              sbb A,(0 ^ 0x80)
 010D C031              jc L17
 010F 2A00              or A,[__rY]
 0111 A01E              jz L22
 0113           X1:
 0113           L24:
 0113 3D0100            cmp [X+1],0
 0116 B006              jnz X2
 0118 3D0255            cmp [X+2],85
 011B A003              jz L20
 011D           X2:
 011D 8021              xjmp L17
 011F           L20:
 011F                   .dbline 61
 011F           ;     case 'U':
 011F           ;         LED_ON();
 011F 430801            or REG[0x8],1
 0122                   .dbline 62
 0122           ;         UART_1_CPutString("!Up!");
 0122 10                push X
 0123 5012              mov A,>L21
 0125 08                push A
 0126 5012              mov A,<L21
 0128 5C                mov X,A
 0129 18                pop A
 012A 7C0000            xcall _UART_1_CPutString
 012D 20                pop X
 012E                   .dbline 63
 012E           ;         break;
 012E 8010              xjmp L18
 0130           L22:
 0130                   .dbline 65
 0130           ;     case 'D':
 0130           ;         LED_OFF();
 0130 4108FE            and REG[0x8],-2
 0133                   .dbline 66
 0133           ;         UART_1_CPutString("!Down!");
 0133 10                push X
 0134 500B              mov A,>L23
 0136 08                push A
 0137 500B              mov A,<L23
 0139 5C                mov X,A
 013A 18                pop A
 013B 7C0000            xcall _UART_1_CPutString
 013E 20                pop X
 013F                   .dbline 67
 013F           ;         break;
 013F           L17:
 013F           L18:
 013F                   .dbline -2
 013F           L16:
 013F 38FD              add SP,-3
 0141 20                pop X
 0142 62D000            mov REG[0xD0],>__r0
 0145 18                pop A
 0146 5300              mov [__rZ],A
 0148 18                pop A
 0149 5300              mov [__rY],A
 014B 18                pop A
 014C 5300              mov [__rX],A
 014E 18                pop A
 014F 5300              mov [__r11],A
 0151 18                pop A
 0152 5300              mov [__r10],A
 0154 18                pop A
 0155 5300              mov [__r9],A
 0157 18                pop A
 0158 5300              mov [__r8],A
 015A 18                pop A
 015B 5300              mov [__r7],A
 015D 18                pop A
 015E 5300              mov [__r6],A
 0160 18                pop A
 0161 5300              mov [__r5],A
 0163 18                pop A
 0164 5300              mov [__r4],A
 0166 18                pop A
 0167 5300              mov [__r3],A
 0169 18                pop A
 016A 5300              mov [__r2],A
 016C 18                pop A
 016D 5300              mov [__r1],A
 016F 18                pop A
 0170 5300              mov [__r0],A
 0172 18                pop A
 0173 60D5              mov REG[213],A
 0175 18                pop A
 0176 60D4              mov REG[212],A
 0178 18                pop A
 0179 60D3              mov REG[211],A
 017B 18                pop A
 017C 60D0              mov REG[208],A
 017E 18                pop A
 017F                   .dbline 0 ; func end
 017F 7E                reti
 0180                   .dbsym l recv_data 0 c
 0180                   .dbend
 0180                   .dbfunc e INT_GPIO _INT_GPIO fV
 0180           _INT_GPIO::
 0180                   .dbline -1
 0180 71C0              or F,-64
 0182 08                push A
 0183 5DD0              mov A,REG[0xd0]
 0185 08                push A
 0186 5DD3              mov A,REG[0xd3]
 0188 08                push A
 0189 5DD4              mov A,REG[0xd4]
 018B 08                push A
 018C 5DD5              mov A,REG[0xd5]
 018E 08                push A
 018F 62D000            mov REG[0xd0],>__r0
 0192 5100              mov A,[__r0]
 0194 08                push A
 0195 5100              mov A,[__r1]
 0197 08                push A
 0198 5100              mov A,[__r2]
 019A 08                push A
 019B 5100              mov A,[__r3]
 019D 08                push A
 019E 5100              mov A,[__r4]
 01A0 08                push A
 01A1 5100              mov A,[__r5]
 01A3 08                push A
 01A4 5100              mov A,[__r6]
 01A6 08                push A
 01A7 5100              mov A,[__r7]
 01A9 08                push A
 01AA 5100              mov A,[__r8]
 01AC 08                push A
 01AD 5100              mov A,[__r9]
 01AF 08                push A
 01B0 5100              mov A,[__r10]
 01B2 08                push A
 01B3 5100              mov A,[__r11]
 01B5 08                push A
 01B6 5100              mov A,[__rX]
 01B8 08                push A
 01B9 5100              mov A,[__rY]
 01BB 08                push A
 01BC 5100              mov A,[__rZ]
 01BE 08                push A
 01BF                   .dbline 72
 01BF           ;     }
 01BF           ; }
 01BF           ; 
 01BF           ; #pragma interrupt_handler INT_GPIO
 01BF           ; void INT_GPIO(void){
 01BF                   .dbline 73
 01BF           ;     if(bit_is_set(SW_PORT, SW_BIT)){
 01BF 5D08              mov A,REG[0x8]
 01C1 62D000            mov REG[0xd0],>__r0
 01C4 5300              mov [__r0],A
 01C6 470004            tst [__r0],4
 01C9 A012              jz L26
 01CB                   .dbline 73
 01CB                   .dbline 74
 01CB           ;     LED_ON();
 01CB 430801            or REG[0x8],1
 01CE                   .dbline 75
 01CE           ;     UART_1_CPutString("ON\r\n");
 01CE 10                push X
 01CF 5006              mov A,>L28
 01D1 08                push A
 01D2 5006              mov A,<L28
 01D4 5C                mov X,A
 01D5 18                pop A
 01D6 7C0000            xcall _UART_1_CPutString
 01D9 20                pop X
 01DA                   .dbline 76
 01DA           ;   }
 01DA 8010              xjmp L27
 01DC           L26:
 01DC                   .dbline 77
 01DC           ;   else{
 01DC                   .dbline 78
 01DC           ;     LED_OFF();
 01DC 4108FE            and REG[0x8],-2
 01DF                   .dbline 79
 01DF           ;     UART_1_CPutString("OFF\r\n");
 01DF 10                push X
 01E0 5000              mov A,>L29
 01E2 08                push A
 01E3 5000              mov A,<L29
 01E5 5C                mov X,A
 01E6 18                pop A
 01E7 7C0000            xcall _UART_1_CPutString
 01EA 20                pop X
 01EB                   .dbline 80
 01EB           ;   }
 01EB           L27:
 01EB                   .dbline -2
 01EB           L25:
 01EB 62D000            mov REG[0xD0],>__r0
 01EE 18                pop A
 01EF 5300              mov [__rZ],A
 01F1 18                pop A
 01F2 5300              mov [__rY],A
 01F4 18                pop A
 01F5 5300              mov [__rX],A
 01F7 18                pop A
 01F8 5300              mov [__r11],A
 01FA 18                pop A
 01FB 5300              mov [__r10],A
 01FD 18                pop A
 01FE 5300              mov [__r9],A
 0200 18                pop A
 0201 5300              mov [__r8],A
 0203 18                pop A
 0204 5300              mov [__r7],A
 0206 18                pop A
 0207 5300              mov [__r6],A
 0209 18                pop A
 020A 5300              mov [__r5],A
 020C 18                pop A
 020D 5300              mov [__r4],A
 020F 18                pop A
 0210 5300              mov [__r3],A
 0212 18                pop A
 0213 5300              mov [__r2],A
 0215 18                pop A
 0216 5300              mov [__r1],A
 0218 18                pop A
 0219 5300              mov [__r0],A
 021B 18                pop A
 021C 60D5              mov REG[213],A
 021E 18                pop A
 021F 60D4              mov REG[212],A
 0221 18                pop A
 0222 60D3              mov REG[211],A
 0224 18                pop A
 0225 60D0              mov REG[208],A
 0227 18                pop A
 0228                   .dbline 0 ; func end
 0228 7E                reti
 0229                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\src\psoc\CY8C29~1\designer\i2c-uart\I2C_MA~1\I2C_MA~1\I2C_MA~1\main.c
 0000           _status::
 0000 00                .byte 0
 0001                   .dbsym e status _status c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\src\psoc\CY8C29~1\designer\i2c-uart\I2C_MA~1\I2C_MA~1\I2C_MA~1\main.c
 0000           _buf_rx::
 0000 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000  .word 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 003C 00000000          .byte 0,0,0,0
 0040                   .dbsym e buf_rx _buf_rx A[64:64]c
                        .area lit(rom, con, rel)
 0000           L29:
 0000 4F46460D0A00      .byte 'O,'F,'F,13,10,0
 0006           L28:
 0006 4F4E0D0A00        .byte 'O,'N,13,10,0
 000B           L23:
 000B 21446F776E2100    .byte 33,'D,'o,'w,'n,33,0
 0012           L21:
 0012 2155702100        .byte 33,'U,'p,33,0
 0017           L2:
 0017 737461727400      .byte 's,'t,'a,'r,'t,0
