 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\src\psoc\CY8C29~1\designer\i2c-uart\I2C_MA~1\I2C_MA~1\I2C_MA~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 26
 0000           ; // I2C-UART master
 0000           ; // CY8C29466-24PXI(DIP Package)
 0000           ; // PSoC Designer 5.0 + SP6
 0000           ; // IMAGECRAFT C Compiler
 0000           ; 
 0000           ; #include <m8c.h>        // part specific constants and macros
 0000           ; #include <I2CHW_1Common.h>
 0000           ; #include <I2CHW_1Mstr.h>
 0000           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0000           ; #define _BV(BIT) (1<<BIT)
 0000           ; #define sbi(BYTE,BIT) (BYTE |= _BV(BIT))
 0000           ; #define cbi(BYTE,BIT) (BYTE &= ~_BV(BIT))
 0000           ; #define LED_ON() sbi(PRT2DR, 0) // LED
 0000           ; #define LED_OFF() cbi(PRT2DR, 0)
 0000           ; #define BTN_PORT PRT2DR // push button
 0000           ; #define BTN_BIT _BV(2)
 0000           ; 
 0000           ; #define BUF_SIZE 8
 0000           ; BYTE buf_tx[BUF_SIZE]; // I2C buffer
 0000           ; BYTE buf_rx[BUF_SIZE];
 0000           ; BYTE status; // I2C status
 0000           ; BYTE slave; // slave address
 0000           ; BYTE wait_count;
 0000           ; 
 0000           ; void main(void)
 0000           ; {
 0000                   .dbline 27
 0000           ;     M8C_EnableGInt; // enable global interrupt
 0000 7101                      or  F, 01h
 0002           
 0002                   .dbline 28
 0002           ;     M8C_EnableIntMask(INT_MSK0, INT_MSK0_GPIO);
 0002 43E020            or REG[0xe0],32
 0005                   .dbline 29
 0005           ;     UART_1_CmdReset(); // uart init
 0005 10                push X
 0006 7C0000            xcall _UART_1_CmdReset
 0009 20                pop X
 000A                   .dbline 30
 000A           ;     UART_1_IntCntl(UART_1_ENABLE_RX_INT); // enable receive interrupt
 000A 10                push X
 000B 5001              mov A,1
 000D 7C0000            xcall _UART_1_IntCntl
 0010 20                pop X
 0011                   .dbline 31
 0011           ;     UART_1_Start(UART_1_PARITY_NONE);
 0011 10                push X
 0012 5000              mov A,0
 0014 7C0000            xcall _UART_1_Start
 0017 20                pop X
 0018                   .dbline 32
 0018           ;     LED_ON();
 0018 430801            or REG[0x8],1
 001B                   .dbline 33
 001B           ;     UART_1_CPutString("start");
 001B 10                push X
 001C 501A              mov A,>L2
 001E 08                push A
 001F 501A              mov A,<L2
 0021 5C                mov X,A
 0022 18                pop A
 0023 7C0000            xcall _UART_1_CPutString
 0026 20                pop X
 0027                   .dbline 34
 0027           ;     LED_OFF();
 0027 4108FE            and REG[0x8],-2
 002A                   .dbline 35
 002A           ;     I2CHW_1_Start();
 002A 10                push X
 002B 7C0000            xcall _I2CHW_1_Start
 002E                   .dbline 36
 002E           ;     I2CHW_1_EnableMstr();
 002E 7C0000            xcall _I2CHW_1_EnableMstr
 0031                   .dbline 37
 0031           ;     I2CHW_1_EnableInt();
 0031 7C0000            xcall _I2CHW_1_EnableInt
 0034 20                pop X
 0035                   .dbline 38
 0035           ;     for(;;){
 0035           L3:
 0035                   .dbline 38
 0035                   .dbline 39
 0035           ;         for(slave = 0x11; slave < 0x21; slave++){
 0035 62D000            mov REG[0xd0],>_slave
 0038 550011            mov [_slave],17
 003B 8100              xjmp L10
 003D           L7:
 003D                   .dbline 39
 003D                   .dbline 40
 003D           ;             I2CHW_1_bWriteBytes(slave, buf_tx, BUF_SIZE, I2CHW_1_CompleteXfer);
 003D 10                push X
 003E 5000              mov A,0
 0040 08                push A
 0041 5008              mov A,8
 0043 08                push A
 0044 5000              mov A,>_buf_tx
 0046 08                push A
 0047 5000              mov A,<_buf_tx
 0049 08                push A
 004A 62D000            mov REG[0xd0],>_slave
 004D 5100              mov A,[_slave]
 004F 08                push A
 0050 7C0000            xcall _I2CHW_1_bWriteBytes
 0053 38FB              add SP,-5
 0055 20                pop X
 0056                   .dbline 41
 0056           ;             wait_count = 0;
 0056 62D000            mov REG[0xd0],>_wait_count
 0059 550000            mov [_wait_count],0
 005C                   .dbline 42
 005C           ;             for(;;){
 005C           L11:
 005C                   .dbline 42
 005C                   .dbline 43
 005C           ;                 if(I2CHW_1_bReadI2CStatus() & I2CHW_WR_COMPLETE ||
 005C 10                push X
 005D 7C0000            xcall _I2CHW_1_bReadI2CStatus
 0060 62D000            mov REG[0xd0],>__r0
 0063 20                pop X
 0064 5300              mov [__r0],A
 0066 470040            tst [__r0],64
 0069 B028              jnz L17
 006B 62D000            mov REG[0xd0],>_wait_count
 006E 5100              mov A,[_wait_count]
 0070 62D000            mov REG[0xd0],>__r0
 0073 5300              mov [__r1],A
 0075 550000            mov [__r0],0
 0078 0101              add A,1
 007A 62D000            mov REG[0xd0],>_wait_count
 007D 5300              mov [_wait_count],A
 007F 62D000            mov REG[0xd0],>__r0
 0082 5064              mov A,100
 0084 1200              sub A,[__r1]
 0086 5000              mov A,0
 0088 3180              xor A,-128
 008A 5300              mov [__rX],A
 008C 5080              mov A,(0 ^ 0x80)
 008E 1A00              sbb A,[__rX]
 0090 DFCB              jnc L11
 0092           X1:
 0092           L17:
 0092                   .dbline 44
 0092           ;                    wait_count++ > 100) break;
 0092                   .dbline 45
 0092           ;             }
 0092                   .dbline 42
 0092                   .dbline 42
 0092           L13:
 0092                   .dbline 46
 0092           ;             I2CHW_1_ClrWrStatus();
 0092 10                push X
 0093 7C0000            xcall _I2CHW_1_ClrWrStatus
 0096 20                pop X
 0097                   .dbline 48
 0097           ;             
 0097           ;             I2CHW_1_fReadBytes(slave, buf_rx, BUF_SIZE, I2CHW_1_CompleteXfer);
 0097 10                push X
 0098 5000              mov A,0
 009A 08                push A
 009B 5008              mov A,8
 009D 08                push A
 009E 5000              mov A,>_buf_rx
 00A0 08                push A
 00A1 5000              mov A,<_buf_rx
 00A3 08                push A
 00A4 62D000            mov REG[0xd0],>_slave
 00A7 5100              mov A,[_slave]
 00A9 08                push A
 00AA 7C0000            xcall _I2CHW_1_fReadBytes
 00AD 38FB              add SP,-5
 00AF 20                pop X
 00B0                   .dbline 49
 00B0           ;             wait_count = 0;
 00B0 62D000            mov REG[0xd0],>_wait_count
 00B3 550000            mov [_wait_count],0
 00B6                   .dbline 50
 00B6           ;             for(;;){
 00B6           L18:
 00B6                   .dbline 50
 00B6                   .dbline 51
 00B6           ;                 if(I2CHW_1_bReadI2CStatus() & I2CHW_RD_COMPLETE ||
 00B6 10                push X
 00B7 7C0000            xcall _I2CHW_1_bReadI2CStatus
 00BA 62D000            mov REG[0xd0],>__r0
 00BD 20                pop X
 00BE 5300              mov [__r0],A
 00C0 470004            tst [__r0],4
 00C3 B028              jnz L24
 00C5 62D000            mov REG[0xd0],>_wait_count
 00C8 5100              mov A,[_wait_count]
 00CA 62D000            mov REG[0xd0],>__r0
 00CD 5300              mov [__r1],A
 00CF 550000            mov [__r0],0
 00D2 0101              add A,1
 00D4 62D000            mov REG[0xd0],>_wait_count
 00D7 5300              mov [_wait_count],A
 00D9 62D000            mov REG[0xd0],>__r0
 00DC 5064              mov A,100
 00DE 1200              sub A,[__r1]
 00E0 5000              mov A,0
 00E2 3180              xor A,-128
 00E4 5300              mov [__rX],A
 00E6 5080              mov A,(0 ^ 0x80)
 00E8 1A00              sbb A,[__rX]
 00EA DFCB              jnc L18
 00EC           X2:
 00EC           L24:
 00EC                   .dbline 52
 00EC           ;                    wait_count++ > 100) break;
 00EC                   .dbline 53
 00EC           ;             }
 00EC                   .dbline 50
 00EC                   .dbline 50
 00EC           L20:
 00EC                   .dbline 54
 00EC           ;             I2CHW_1_ClrRdStatus();
 00EC 10                push X
 00ED 7C0000            xcall _I2CHW_1_ClrRdStatus
 00F0 20                pop X
 00F1           L25:
 00F1                   .dbline 56
 00F1           ; 
 00F1           ;             while(!(UART_1_bReadTxStatus() & UART_1_TX_BUFFER_EMPTY));
 00F1           L26:
 00F1                   .dbline 56
 00F1 10                push X
 00F2 7C0000            xcall _UART_1_bReadTxStatus
 00F5 62D000            mov REG[0xd0],>__r0
 00F8 20                pop X
 00F9 5300              mov [__r0],A
 00FB 470010            tst [__r0],16
 00FE AFF2              jz L25
 0100                   .dbline 57
 0100           ;             UART_1_CPutString("I2C:");
 0100 10                push X
 0101 5015              mov A,>L28
 0103 08                push A
 0104 5015              mov A,<L28
 0106 5C                mov X,A
 0107 18                pop A
 0108 7C0000            xcall _UART_1_CPutString
 010B 20                pop X
 010C                   .dbline 58
 010C           ;             UART_1_PutSHexByte(slave); // slaveアドレス
 010C 10                push X
 010D 62D000            mov REG[0xd0],>_slave
 0110 5100              mov A,[_slave]
 0112 7C0000            xcall _UART_1_PutSHexByte
 0115 20                pop X
 0116                   .dbline 59
 0116           ;             UART_1_CPutString(",");
 0116 10                push X
 0117 5013              mov A,>L29
 0119 08                push A
 011A 5013              mov A,<L29
 011C 5C                mov X,A
 011D 18                pop A
 011E 7C0000            xcall _UART_1_CPutString
 0121 20                pop X
 0122                   .dbline 60
 0122           ;             UART_1_PutString(buf_rx); // slaveからの受信データ
 0122 10                push X
 0123 5000              mov A,>_buf_rx
 0125 08                push A
 0126 5000              mov A,<_buf_rx
 0128 5C                mov X,A
 0129 18                pop A
 012A 7C0000            xcall _UART_1_PutString
 012D                   .dbline 61
 012D           ;             UART_1_PutCRLF();
 012D 7C0000            xcall _UART_1_PutCRLF
 0130 20                pop X
 0131                   .dbline 62
 0131           ;             buf_rx[0] = '\0'; // 受信バッファを初期化
 0131 62D000            mov REG[0xd0],>_buf_rx
 0134 550000            mov [_buf_rx],0
 0137                   .dbline 63
 0137           ;         }
 0137           L8:
 0137                   .dbline 39
 0137 62D000            mov REG[0xd0],>_slave
 013A 7600              inc [_slave]
 013C           L10:
 013C                   .dbline 39
 013C 62D000            mov REG[0xd0],>_slave
 013F 3C0021            cmp [_slave],33
 0142 CEFA              jc L7
 0144           X3:
 0144                   .dbline 64
 0144           ;     }
 0144                   .dbline 38
 0144                   .dbline 38
 0144 8EF0              xjmp L3
 0146           X0:
 0146                   .dbline -2
 0146           L1:
 0146                   .dbline 0 ; func end
 0146 8FFF              jmp .
 0148                   .dbend
 0148                   .dbfunc e INT_UART_RX _INT_UART_RX fV
 0148           ;      recv_data -> X+0
 0148           _INT_UART_RX::
 0148                   .dbline -1
 0148 71C0              or F,-64
 014A 08                push A
 014B 5DD0              mov A,REG[0xd0]
 014D 08                push A
 014E 5DD3              mov A,REG[0xd3]
 0150 08                push A
 0151 5DD4              mov A,REG[0xd4]
 0153 08                push A
 0154 5DD5              mov A,REG[0xd5]
 0156 08                push A
 0157 62D000            mov REG[0xd0],>__r0
 015A 5100              mov A,[__r0]
 015C 08                push A
 015D 5100              mov A,[__r1]
 015F 08                push A
 0160 5100              mov A,[__r2]
 0162 08                push A
 0163 5100              mov A,[__r3]
 0165 08                push A
 0166 5100              mov A,[__r4]
 0168 08                push A
 0169 5100              mov A,[__r5]
 016B 08                push A
 016C 5100              mov A,[__r6]
 016E 08                push A
 016F 5100              mov A,[__r7]
 0171 08                push A
 0172 5100              mov A,[__r8]
 0174 08                push A
 0175 5100              mov A,[__r9]
 0177 08                push A
 0178 5100              mov A,[__r10]
 017A 08                push A
 017B 5100              mov A,[__r11]
 017D 08                push A
 017E 5100              mov A,[__rX]
 0180 08                push A
 0181 5100              mov A,[__rY]
 0183 08                push A
 0184 5100              mov A,[__rZ]
 0186 08                push A
 0187 10                push X
 0188 4F                mov X,SP
 0189 3803              add SP,3
 018B                   .dbline 70
 018B           ; }
 018B           ; 
 018B           ; 
 018B           ; // UART受信割り込み
 018B           ; #pragma interrupt_handler INT_UART_RX
 018B           ; void INT_UART_RX(void){
 018B                   .dbline 72
 018B           ;     char recv_data;
 018B           ;     recv_data = UART_1_cGetChar(); // read UART
 018B 10                push X
 018C 7C0000            xcall _UART_1_cGetChar
 018F 62D000            mov REG[0xd0],>__r0
 0192 20                pop X
 0193 5400              mov [X+0],A
 0195                   .dbline 73
 0195           ;     UART_1_PutChar(recv_data); // echo
 0195 10                push X
 0196 5200              mov A,[X+0]
 0198 7C0000            xcall _UART_1_PutChar
 019B 20                pop X
 019C                   .dbline 74
 019C           ;     switch(recv_data){
 019C 5200              mov A,[X+0]
 019E 5402              mov [X+2],A
 01A0 560100            mov [X+1],0
 01A3 5202              mov A,[X+2]
 01A5 1144              sub A,68
 01A7 62D000            mov REG[0xd0],>__r0
 01AA 5300              mov [__rY],A
 01AC 5201              mov A,[X+1]
 01AE 3180              xor A,-128
 01B0 1980              sbb A,(0 ^ 0x80)
 01B2 C03D              jc L31
 01B4 2A00              or A,[__rY]
 01B6 A024              jz L36
 01B8           X4:
 01B8           L38:
 01B8 3D0100            cmp [X+1],0
 01BB B006              jnz X5
 01BD 3D0255            cmp [X+2],85
 01C0 A003              jz L34
 01C2           X5:
 01C2 802D              xjmp L31
 01C4           L34:
 01C4                   .dbline 76
 01C4           ;     case 'U':
 01C4           ;         LED_ON();
 01C4 430801            or REG[0x8],1
 01C7                   .dbline 77
 01C7           ;         buf_tx[0] = 'A'; // slaveにLED点灯を指示
 01C7 62D000            mov REG[0xd0],>_buf_tx
 01CA 550041            mov [_buf_tx],65
 01CD                   .dbline 78
 01CD           ;         UART_1_CPutString("LED:ON\r\n");
 01CD 10                push X
 01CE 500A              mov A,>L35
 01D0 08                push A
 01D1 500A              mov A,<L35
 01D3 5C                mov X,A
 01D4 18                pop A
 01D5 7C0000            xcall _UART_1_CPutString
 01D8 20                pop X
 01D9                   .dbline 79
 01D9           ;         break;
 01D9 8016              xjmp L32
 01DB           L36:
 01DB                   .dbline 81
 01DB           ;     case 'D':
 01DB           ;         LED_OFF();
 01DB 4108FE            and REG[0x8],-2
 01DE                   .dbline 82
 01DE           ;         buf_tx[0] = 'B'; // slaveにLED消灯を指示
 01DE 62D000            mov REG[0xd0],>_buf_tx
 01E1 550042            mov [_buf_tx],66
 01E4                   .dbline 83
 01E4           ;         UART_1_CPutString("LED:OFF\r\n");
 01E4 10                push X
 01E5 5000              mov A,>L37
 01E7 08                push A
 01E8 5000              mov A,<L37
 01EA 5C                mov X,A
 01EB 18                pop A
 01EC 7C0000            xcall _UART_1_CPutString
 01EF 20                pop X
 01F0                   .dbline 84
 01F0           ;         break;
 01F0           L31:
 01F0           L32:
 01F0                   .dbline -2
 01F0           L30:
 01F0 38FD              add SP,-3
 01F2 20                pop X
 01F3 62D000            mov REG[0xD0],>__r0
 01F6 18                pop A
 01F7 5300              mov [__rZ],A
 01F9 18                pop A
 01FA 5300              mov [__rY],A
 01FC 18                pop A
 01FD 5300              mov [__rX],A
 01FF 18                pop A
 0200 5300              mov [__r11],A
 0202 18                pop A
 0203 5300              mov [__r10],A
 0205 18                pop A
 0206 5300              mov [__r9],A
 0208 18                pop A
 0209 5300              mov [__r8],A
 020B 18                pop A
 020C 5300              mov [__r7],A
 020E 18                pop A
 020F 5300              mov [__r6],A
 0211 18                pop A
 0212 5300              mov [__r5],A
 0214 18                pop A
 0215 5300              mov [__r4],A
 0217 18                pop A
 0218 5300              mov [__r3],A
 021A 18                pop A
 021B 5300              mov [__r2],A
 021D 18                pop A
 021E 5300              mov [__r1],A
 0220 18                pop A
 0221 5300              mov [__r0],A
 0223 18                pop A
 0224 60D5              mov REG[213],A
 0226 18                pop A
 0227 60D4              mov REG[212],A
 0229 18                pop A
 022A 60D3              mov REG[211],A
 022C 18                pop A
 022D 60D0              mov REG[208],A
 022F 18                pop A
 0230                   .dbline 0 ; func end
 0230 7E                reti
 0231                   .dbsym l recv_data 0 c
 0231                   .dbend
 0231                   .dbfunc e INT_GPIO _INT_GPIO fV
 0231           _INT_GPIO::
 0231                   .dbline -1
 0231 71C0              or F,-64
 0233 08                push A
 0234 5DD0              mov A,REG[0xd0]
 0236 08                push A
 0237 5DD3              mov A,REG[0xd3]
 0239 08                push A
 023A 5DD4              mov A,REG[0xd4]
 023C 08                push A
 023D 5DD5              mov A,REG[0xd5]
 023F 08                push A
 0240 62D000            mov REG[0xd0],>__r0
 0243 5100              mov A,[__r0]
 0245 08                push A
 0246 5100              mov A,[__r1]
 0248 08                push A
 0249 5100              mov A,[__r2]
 024B 08                push A
 024C 5100              mov A,[__r3]
 024E 08                push A
 024F 5100              mov A,[__r4]
 0251 08                push A
 0252 5100              mov A,[__r5]
 0254 08                push A
 0255 5100              mov A,[__r6]
 0257 08                push A
 0258 5100              mov A,[__r7]
 025A 08                push A
 025B 5100              mov A,[__r8]
 025D 08                push A
 025E 5100              mov A,[__r9]
 0260 08                push A
 0261 5100              mov A,[__r10]
 0263 08                push A
 0264 5100              mov A,[__r11]
 0266 08                push A
 0267 5100              mov A,[__rX]
 0269 08                push A
 026A 5100              mov A,[__rY]
 026C 08                push A
 026D 5100              mov A,[__rZ]
 026F 08                push A
 0270                   .dbline 90
 0270           ;     }
 0270           ; }
 0270           ; 
 0270           ; // I/Oピン状態変化割り込み
 0270           ; #pragma interrupt_handler INT_GPIO
 0270           ; void INT_GPIO(void){
 0270                   .dbline 91
 0270           ;     if(BTN_PORT & BTN_BIT){ // ボタンが押されている時
 0270 5D08              mov A,REG[0x8]
 0272 62D000            mov REG[0xd0],>__r0
 0275 5300              mov [__r0],A
 0277 470004            tst [__r0],4
 027A A018              jz L40
 027C                   .dbline 91
 027C                   .dbline 92
 027C           ;     LED_ON();
 027C 430801            or REG[0x8],1
 027F                   .dbline 93
 027F           ;     buf_tx[0] = 'A'; // slaveにLED点灯を指示
 027F 62D000            mov REG[0xd0],>_buf_tx
 0282 550041            mov [_buf_tx],65
 0285                   .dbline 94
 0285           ;     UART_1_CPutString("LED:ON\r\n");
 0285 10                push X
 0286 500A              mov A,>L35
 0288 08                push A
 0289 500A              mov A,<L35
 028B 5C                mov X,A
 028C 18                pop A
 028D 7C0000            xcall _UART_1_CPutString
 0290 20                pop X
 0291                   .dbline 95
 0291           ;   }
 0291 8016              xjmp L41
 0293           L40:
 0293                   .dbline 96
 0293           ;   else{
 0293                   .dbline 97
 0293           ;     LED_OFF();
 0293 4108FE            and REG[0x8],-2
 0296                   .dbline 98
 0296           ;     buf_tx[0] = 'B'; // slaveにLED消灯を指示
 0296 62D000            mov REG[0xd0],>_buf_tx
 0299 550042            mov [_buf_tx],66
 029C                   .dbline 99
 029C           ;     UART_1_CPutString("LED:OFF\r\n");
 029C 10                push X
 029D 5000              mov A,>L37
 029F 08                push A
 02A0 5000              mov A,<L37
 02A2 5C                mov X,A
 02A3 18                pop A
 02A4 7C0000            xcall _UART_1_CPutString
 02A7 20                pop X
 02A8                   .dbline 100
 02A8           ;   }
 02A8           L41:
 02A8                   .dbline -2
 02A8           L39:
 02A8 62D000            mov REG[0xD0],>__r0
 02AB 18                pop A
 02AC 5300              mov [__rZ],A
 02AE 18                pop A
 02AF 5300              mov [__rY],A
 02B1 18                pop A
 02B2 5300              mov [__rX],A
 02B4 18                pop A
 02B5 5300              mov [__r11],A
 02B7 18                pop A
 02B8 5300              mov [__r10],A
 02BA 18                pop A
 02BB 5300              mov [__r9],A
 02BD 18                pop A
 02BE 5300              mov [__r8],A
 02C0 18                pop A
 02C1 5300              mov [__r7],A
 02C3 18                pop A
 02C4 5300              mov [__r6],A
 02C6 18                pop A
 02C7 5300              mov [__r5],A
 02C9 18                pop A
 02CA 5300              mov [__r4],A
 02CC 18                pop A
 02CD 5300              mov [__r3],A
 02CF 18                pop A
 02D0 5300              mov [__r2],A
 02D2 18                pop A
 02D3 5300              mov [__r1],A
 02D5 18                pop A
 02D6 5300              mov [__r0],A
 02D8 18                pop A
 02D9 60D5              mov REG[213],A
 02DB 18                pop A
 02DC 60D4              mov REG[212],A
 02DE 18                pop A
 02DF 60D3              mov REG[211],A
 02E1 18                pop A
 02E2 60D0              mov REG[208],A
 02E4 18                pop A
 02E5                   .dbline 0 ; func end
 02E5 7E                reti
 02E6                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\src\psoc\CY8C29~1\designer\i2c-uart\I2C_MA~1\I2C_MA~1\I2C_MA~1\main.c
 0000           _wait_count::
 0000 00                .byte 0
 0001                   .dbsym e wait_count _wait_count c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\src\psoc\CY8C29~1\designer\i2c-uart\I2C_MA~1\I2C_MA~1\I2C_MA~1\main.c
 0000           _slave::
 0000 00                .byte 0
 0001                   .dbsym e slave _slave c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\src\psoc\CY8C29~1\designer\i2c-uart\I2C_MA~1\I2C_MA~1\I2C_MA~1\main.c
 0000           _status::
 0000 00                .byte 0
 0001                   .dbsym e status _status c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\src\psoc\CY8C29~1\designer\i2c-uart\I2C_MA~1\I2C_MA~1\I2C_MA~1\main.c
 0000           _buf_rx::
 0000 0000000000000000  .byte 0,0,0,0,0,0,0,0
 0008                   .dbsym e buf_rx _buf_rx A[8:8]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\src\psoc\CY8C29~1\designer\i2c-uart\I2C_MA~1\I2C_MA~1\I2C_MA~1\main.c
 0000           _buf_tx::
 0000 0000000000000000  .byte 0,0,0,0,0,0,0,0
 0008                   .dbsym e buf_tx _buf_tx A[8:8]c
                        .area lit(rom, con, rel)
 0000           L37:
 0000 4C45443A4F46460D0A00      .byte 'L,'E,'D,58,'O,'F,'F,13,10,0
 000A           L35:
 000A 4C45443A4F4E0D0A00        .byte 'L,'E,'D,58,'O,'N,13,10,0
 0013           L29:
 0013 2C00              .byte 44,0
 0015           L28:
 0015 4932433A00        .byte 'I,50,'C,58,0
 001A           L2:
 001A 737461727400      .byte 's,'t,'a,'r,'t,0
